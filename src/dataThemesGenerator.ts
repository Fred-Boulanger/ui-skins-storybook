import { readFile, writeFile } from 'node:fs/promises'
import { glob } from 'glob'
import { parse } from 'yaml'
import { join, resolve } from 'node:path'

export interface ThemeConfig {
  key: string
  label: string
  value: string
  target: string
}

export interface ThemeGeneratorOptions {
  namespaces?: Record<string, string>
}

/**
 * Generate Storybook data-themes.ts configuration from *.ui_skins.themes.yml files
 */
export async function generateThemes(options: ThemeGeneratorOptions = {}): Promise<void> {
  console.log('ðŸŽ¨ Generating theme configuration from *.ui_skins.themes.yml files...')
  
  try {
    // Find all theme files in current directory and namespaces
    const searchPaths = [process.cwd()]
    
    // Add namespace paths if provided
    if (options.namespaces) {
      for (const [namespaceName, namespacePath] of Object.entries(options.namespaces)) {
        const resolvedPath = resolve(namespacePath)
        searchPaths.push(resolvedPath)
        console.log(`ðŸ” Searching themes in namespace '${namespaceName}': ${resolvedPath}`)
      }
    }
    
    // Search for theme files in all paths
    const themeFiles: string[] = []
    for (const searchPath of searchPaths) {
      try {
        const files = await glob('**/*.ui_skins.themes.yml', { cwd: searchPath })
        themeFiles.push(...files.map(file => join(searchPath, file)))
      } catch (error) {
        console.log(`âš ï¸  Could not search in path: ${searchPath}`)
      }
    }
    
    if (themeFiles.length === 0) {
      console.log('âš ï¸  No *.ui_skins.themes.yml files found - skipping theme generation')
      return
    }
    
    console.log(`ðŸ“ Found ${themeFiles.length} theme file(s):`, themeFiles)
    
    const themes: ThemeConfig[] = []
    
    // Parse each theme file
    for (const themeFile of themeFiles) {
      try {
        const content = await readFile(themeFile, 'utf8')
        const themeData = parse(content)
        
        // Extract theme information
        for (const [themeKey, themeConfig] of Object.entries(themeData)) {
          if (typeof themeConfig === 'object' && themeConfig !== null) {
            const config = themeConfig as any
            
            // Check if theme has required properties: label, key, and target
            if (config.label && config.key && config.target) {
              themes.push({
                key: themeKey,
                label: config.label,
                value: themeKey,
                target: config.target
              })
              console.log(`âœ… Added theme: ${themeKey} (${config.label}) -> ${config.target}`)
            } else {
              console.log(`âš ï¸  Skipped theme: ${themeKey} - missing required properties (label, key, target)`)
            }
          }
        }
        
        console.log(`âœ… Parsed theme file: ${themeFile}`)
      } catch (error) {
        console.error(`âŒ Error parsing ${themeFile}:`, (error as Error).message)
      }
    }
    
    if (themes.length === 0) {
      console.log('âš ï¸  No valid themes found in the files - skipping theme generation')
      // Remove existing data-themes.ts file if it exists
      const themesConfigPath = join(process.cwd(), '.storybook', 'data-themes.ts')
      try {
        await writeFile(themesConfigPath, '', 'utf8')
        console.log(`ðŸ—‘ï¸  Cleared existing data-themes.ts file`)
      } catch (error) {
        // File might not exist, which is fine
      }
      return
    }
    
    console.log(`ðŸŽ¯ Found ${themes.length} theme(s):`, themes.map(t => t.key))
    
    // Generate the themes configuration file
    const themesConfigContent = generateThemesConfig(themes)
    const themesConfigPath = join(process.cwd(), '.storybook', 'data-themes.ts')
    await writeFile(themesConfigPath, themesConfigContent, 'utf8')
    
    console.log(`âœ… Generated data-themes.ts with ${themes.length} theme(s)`)
    console.log(`ðŸ“ Updated: ${themesConfigPath}`)
    console.log(`ðŸ’¡ To use themes, add to your preview.ts:`)
    console.log(`   import { themeDecorators, themeGlobalTypes } from './data-themes'`)
    console.log(`   Then add ...themeDecorators to decorators and ...themeGlobalTypes to globalTypes`)
    
  } catch (error) {
    console.error('âŒ Error generating themes:', error)
    throw error
  }
}

/**
 * Generate the themes configuration file
 */
export function generateThemesConfig(themes: ThemeConfig[]): string {
  const themeItems = themes.map(theme => 
    `        { value: '${theme.value}', title: '${theme.label}' }`
  ).join(',\n')
  
  const defaultTheme = themes.length > 0 ? themes[0].value : 'default'
  const defaultTarget = themes.length > 0 ? themes[0].target : 'body'
  
  // Create theme target mapping
  const themeTargets = themes.map(theme => 
    `    '${theme.value}': '${theme.target}'`
  ).join(',\n')
  
  return `// Auto-generated theme configuration from *.ui_skins.themes.yml files
// This file is automatically generated - do not edit manually

// Theme target mapping
const themeTargets = {
${themeTargets}
};

// Add a decorator to set data-theme on the correct target element
export const themeDecorators = [
  (storyFn, context) => {
    // Wait for the target element to be available
    setTimeout(() => {
      const selectedTheme = context.globals.theme || '${defaultTheme}';
      const targetSelector = themeTargets[selectedTheme] || '${defaultTarget}';
      
      // Remove data-theme from both html and body to clean previous themes
      const html = document.querySelector('html');
      const body = document.querySelector('body');
      if (html) html.removeAttribute('data-theme');
      if (body) body.removeAttribute('data-theme');
      
      // Apply the new theme to the correct target
      const target = document.querySelector(targetSelector);
      if (target) {
        target.setAttribute('data-theme', selectedTheme);
      }
    }, 0);
    return storyFn();
  },
];

export const themeGlobalTypes = {
  theme: {
    name: 'Theme',
    description: 'Global theme for components',
    defaultValue: '${defaultTheme}',
    toolbar: {
      icon: 'paintbrush',
      items: [
${themeItems}
      ],
    },
  },
};
`
}
